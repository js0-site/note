#!/usr/bin/env -S node --trace-uncaught --expose-gc --unhandled-rejections=strict --experimental-wasm-modules
var BUILDIN, CamelCase, _buildin, _import, _import_line, _mod_name, hash;

import camel from '@3-/camel';

import {
  upperFirst
} from 'lodash-es';

CamelCase = (x) => {
  var r;
  r = camel(x);
  if (r !== x) {
    return upperFirst(r);
  } else {
    return x;
  }
};

_mod_name = (i, convert = CamelCase) => {
  var dot, ext, name, pos;
  pos = i.lastIndexOf(':');
  if (pos < 0) {
    name = i.split('/').pop();
    dot = name.lastIndexOf('.');
    if (dot > 0) {
      ext = name.slice(dot + 1);
      if (~['css', 'styl'].indexOf(ext)) {
        name = '';
      } else {
        name = name.slice(0, dot);
      }
    }
    return [convert(name), i];
  } else {
    return [i.slice(pos + 1), _buildin(i, pos)];
  }
};

_import_line = function(code) {
  var mod, name;
  [name, mod] = _mod_name(code);
  if (name) {
    return `import ${name} from '${mod}'`;
  } else {
    return `import '${mod}'`;
  }
};

hash = '#';

BUILDIN = ['bun', 'npm', 'node'];

_buildin = (mod, pos) => {
  var _mod;
  _mod = mod.slice(0, pos);
  if (BUILDIN.indexOf(_mod) < 0) {
    return _mod;
  } else {
    return mod;
  }
};

_import = function*(bk) {
  var func, func_li, gt_pos, i, import_li, j, len, li, mod, pos, r, ref, rename;
  for (li of bk) {
    if (li.charAt(0) === hash) {
      yield li;
      continue;
    }
    li = li.slice(1).trim();
    if (li) {
      if (li.startsWith(hash)) {
        yield li;
        continue;
      }
      pos = li.lastIndexOf(hash);
      if (pos > 0) {
        li = li.slice(0, pos).trimEnd();
      }
      li = li.split(' ');
      gt_pos = li.indexOf('>');
      if (gt_pos > 0) {
        import_li = li.slice(0, gt_pos - 1);
      } else {
        import_li = li;
      }
      r = import_li.map(_import_line);
      if (gt_pos > 0) {
        mod = li[gt_pos - 1];
        pos = mod.lastIndexOf(':');
        if (pos > 0) {
          rename = mod.slice(pos + 1);
          mod = mod.slice(0, pos);
          if (BUILDIN.indexOf(mod) < 0) {
            if (rename === '@') {
              rename = mod.split('/').pop().split('.')[0];
              rename = CamelCase(rename);
            }
            r.push(`import ${rename} from '${mod}'`);
          }
        }
        func_li = [];
        ref = li.slice(gt_pos + 1);
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          [rename, func] = _mod_name(i, (x) => {
            return x;
          });
          if (rename === func) {
            func_li.push(func);
          } else {
            func_li.push(`${func} as ${rename}`);
          }
        }
        if (func_li.length > 0) {
          r.push(`import {${func_li.join(',')}} from '${mod}'`);
        }
      }
      yield r.join(';');
    } else {
      yield '';
    }
  }
};

export default function*(code) {
  var bk, i, in_gt, trim;
  in_gt = false;
  bk = [];
  for (i of code) {
    trim = i.trimEnd();
    if (trim) {
      if (i.startsWith('>')) {
        in_gt = true;
        bk.push(i);
      } else if (in_gt) {
        if (i.charAt(0) !== ' ') {
          in_gt = false;
          yield* _import(bk);
          bk = [];
          yield i;
        } else {
          bk.push(i);
        }
      } else {
        yield i;
      }
    } else {
      yield i;
    }
  }
  if (bk.length) {
    return (yield* _import(bk));
  }
};
