var _walk, walk;

import {
  opendir,
  readlink,
  stat
} from 'fs/promises';

import {
  dirname,
  join,
  normalize
} from "path";

walk = async function*(dir, ignore = () => {}, meta = void 0) {
  var d, entry, err, exist, i, p, ref, ref1, root, s;
  if (meta) {
    [exist, root] = meta;
  } else {
    exist = new Set();
    root = dir;
  }
  ref = (await opendir(dir));
  for await (d of ref) {
    entry = join(root, d.name);
    if (ignore(entry)) {
      continue;
    }
    if (d.isDirectory()) {
      yield* walk(entry, ignore, [exist, join(root, d.name)]);
    } else if (d.isFile()) {
      yield entry;
    } else if (d.isSymbolicLink()) {
      p = (await readlink(entry));
      if (!p.startsWith('/')) {
        p = normalize(join(dir, p));
      }
      try {
        s = (await stat(p));
      } catch (error) {
        err = error;
        continue;
      }
      if (s.isDirectory()) {
        if (exist.has(p)) {
          continue;
        }
        exist.add(p);
        ref1 = walk(p, ignore, [exist, join(root, d.name)]);
        for await (i of ref1) {
          yield i;
        }
      } else if (s.isFile()) {
        yield entry;
      }
    }
  }
};

if (process.platform === 'win32') {
  _walk = walk;
  walk = async function*(...args) {
    var i, ref;
    ref = _walk.apply(this, arguments);
    for await (i of ref) {
      yield i.replaceAll('\\', '/');
    }
  };
}

export default walk;

export var walkRel = async function*(dir, ignore) {
  var _ignore, d, len, ref;
  len = dir.length + 1;
  if (ignore) {
    _ignore = (p) => {
      return ignore(p.slice(len));
    };
  }
  ref = walk(dir, _ignore);
  for await (d of ref) {
    yield d.slice(len);
  }
};
